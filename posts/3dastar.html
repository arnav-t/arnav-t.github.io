<!doctype html>
<html lang="en-us">
  <head>
    <title>Navigating 2D objects using 3D configuration spaces // Arnav Tiwari</title>
    <link rel="shortcut icon" href="../favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.79.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="arnav-t" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://arnav-t.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Navigating 2D objects using 3D configuration spaces"/>
<meta name="twitter:description" content="Using 3D configuration spaces for navigating 2D objects with A* pathfinding algorithm Pathfinding is a very interesting problem. There are already many popular algorithms for finding a path from point A to B such as Dijkstra&rsquo;s algorithm and A* algorithm. However, they operate on the assumption that your path can *squeeze* through the smallest of gaps. Clearly, this would be a problem if you wanted to find a path for a finite object."/>

    <meta property="og:title" content="Navigating 2D objects using 3D configuration spaces" />
<meta property="og:description" content="Using 3D configuration spaces for navigating 2D objects with A* pathfinding algorithm Pathfinding is a very interesting problem. There are already many popular algorithms for finding a path from point A to B such as Dijkstra&rsquo;s algorithm and A* algorithm. However, they operate on the assumption that your path can *squeeze* through the smallest of gaps. Clearly, this would be a problem if you wanted to find a path for a finite object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://arnav-t.github.io/posts/3dastar.html" />
<meta property="article:published_time" content="2018-03-09T01:06:18+05:30" />
<meta property="article:modified_time" content="2018-03-09T01:06:18+05:30" />


  </head>
  <body>
    <header class="app-header">
      <a href="http://arnav-t.github.io/"><img class="app-header-avatar" src="../images/arnav-t.jpg" alt="arnav-t" /></a>
      <h1>Arnav Tiwari</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="../about/">About</a>
             - 
          
          <a class="app-header-menu-item" href="../">Posts</a>
             - 
          
          <a class="app-header-menu-item" href="../tags/">Tags</a>
      </nav>
      <p>An unassorted collection of my ramblings on software and cybersecurity.</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/arnav-t" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://www.linkedin.com/in/arnav-t" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg></a>
        
          <a target="_blank" href="https://stackoverflow.com/users/3127633/avz" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
          <a target="_blank" href="https://www.youtube.com/channel/UCg2dm7SxYUOg4VLujWFxo8A" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-youtube">
  <title>youtube</title>
  <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>
</svg></a>
        
          <a target="_blank" href="mailto:avznav@gmail.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Navigating 2D objects using 3D configuration spaces</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 9, 2018
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="http://arnav-t.github.io/tags/algorithms.html">Algorithms</a>
              <a class="tag" href="http://arnav-t.github.io/tags/pathfinding.html">Pathfinding</a>
              <a class="tag" href="http://arnav-t.github.io/tags/c&#43;&#43;.html">C&#43;&#43;</a>
              <a class="tag" href="http://arnav-t.github.io/tags/2018.html">2018</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="using-3d-configuration-spaces-for-navigating-2d-objects-with-a-pathfinding-algorithm">Using 3D configuration spaces for navigating 2D objects with A* pathfinding algorithm</h2>
<p><img src="https://raw.githubusercontent.com/arnav-t/AGV_1/master/10x20_new_png.png" alt="Example path"></p>
<p>Pathfinding is a very interesting problem. There are already many popular algorithms for finding a path from point A to B such as Dijkstra&rsquo;s algorithm and A* algorithm. However, they operate on the assumption that your path can *squeeze* through the smallest of gaps. Clearly, this would be a problem if you wanted to find a path for a finite object. The object wouldn&rsquo;t be able to squeeze through small gaps the pathfinding algorithm may take. So, what do we do? We need to modify the algorithm to take into account the dimensions of the object. Perhaps we could modify the map itself?</p>
<h3 id="minkowski-sum">Minkowski Sum</h3>
<p><img src="../images/minkowski.jpg" alt="Minkowski Sum"></p>
<p>Let&rsquo;s lock in the orientation of the object for the moment. We can take the map and replace it with its Minkowski sum with our object. Minkowski sum, when taken with our object (but reflected about the origin), is like the map of where our object couldn&rsquo;t be. Luckily, if one of our operands is a convex polygon (in this case, our object), taking the Minkowski sum is quite simple. More information on how to implement it can be found <a href="https://resources.mpi-inf.mpg.de/departments/d1/teaching/ss10/Seminar_CGGC/Slides/07_Bock_MS.pdf">here</a>.<br>
Once we have our new map, we can simply apply our old pathfinding algorithm to it and obtain a path. However, even though our object can feasibly navigate the path we calculate using this method, it won&rsquo;t be the most optimal as we have entirely ignored a degree of freedom &ndash;  orientation!<br>
For example, if our object was a long rectangle, it may be able to fit through a gap from one side but not the other. We need to be able to take this into account. Enter: the configuration space.</p>
<h3 id="configuration-spaces">Configuration Spaces</h3>
<p>The truth is, we&rsquo;ve already been using the configuration space for a while. We&rsquo;re just about to add another dimension to it for handling orientation.<br>
Remember how we previously locked in our orientation in the previous section? We can, in a loop, calculate the Minkowski sums of all these orientations and stack them on top of each other to obtain a 3D configuration space. Depending upon our required granularity for orientations, we can generate a Minkowski sum for every <code>x</code> radians, which would give us <code>x/(2*pi)</code> slices in our 3D plane. Naturally, increasing the granularity speeds up the simulation at the cost of quality.<br>
Here is an example in C++ and OpenCV for calculating a configuration space &ldquo;slice&rdquo; for a rectangular object at a given angle using the contours of our map:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createCSpace</span>(<span style="color:#66d9ef">float</span> angle, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>cv<span style="color:#f92672">::</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> contours)
{
	OCVWrapper cPlane(<span style="color:#66d9ef">int</span>(imgMap<span style="color:#f92672">-&gt;</span>getWidth()), <span style="color:#66d9ef">int</span>(imgMap<span style="color:#f92672">-&gt;</span>getHeight()), false);
	cPlane.drawContours<span style="color:#f92672">&lt;</span>uchar<span style="color:#f92672">&gt;</span>(contours, <span style="color:#ae81ff">255</span>, CV_FILLED);
	std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>cv<span style="color:#f92672">::</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> polygons;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> contours.size(); <span style="color:#f92672">++</span>j)
	{
		
		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> contours[j].size();<span style="color:#f92672">++</span>i)
		{
			cv<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>cv<span style="color:#f92672">::</span>Point<span style="color:#f92672">&gt;</span> rotatedRect;
			cv<span style="color:#f92672">::</span>Point origin <span style="color:#f92672">=</span> contours[j][i];
			<span style="color:#75715e">// Coordinates reflected about origin for the minkowski sum to give the 2D configurational space
</span><span style="color:#75715e"></span>			rotatedRect.clear();
			rotatedRect.push_back(origin);
			rotatedRect.push_back(origin <span style="color:#f92672">+</span> cv<span style="color:#f92672">::</span>Point(<span style="color:#f92672">-</span>bHeight<span style="color:#f92672">*</span>sin(angle), <span style="color:#f92672">-</span>bHeight<span style="color:#f92672">*</span>cos(angle)));
			rotatedRect.push_back(origin <span style="color:#f92672">+</span> cv<span style="color:#f92672">::</span>Point(<span style="color:#f92672">-</span>bHeight<span style="color:#f92672">*</span>sin(angle) <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span>bWidth)<span style="color:#f92672">*</span>sin(angle <span style="color:#f92672">+</span> M_PI<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>), <span style="color:#f92672">-</span>bHeight<span style="color:#f92672">*</span>cos(angle) <span style="color:#f92672">+</span> (<span style="color:#f92672">-</span>bWidth)<span style="color:#f92672">*</span>cos(angle <span style="color:#f92672">+</span> M_PI<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)));
			rotatedRect.push_back(origin <span style="color:#f92672">+</span> cv<span style="color:#f92672">::</span>Point(<span style="color:#f92672">-</span>bWidth<span style="color:#f92672">*</span>sin(angle <span style="color:#f92672">+</span> M_PI<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>), <span style="color:#f92672">-</span>bWidth<span style="color:#f92672">*</span>cos(angle <span style="color:#f92672">+</span> M_PI<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)));

			polygons.push_back(rotatedRect);
		}
	}
	cPlane.drawPoly<span style="color:#f92672">&lt;</span>uchar<span style="color:#f92672">&gt;</span>(polygons, <span style="color:#ae81ff">255</span>);
	cSpace.push_back(cPlane);
}
</code></pre></div><h3 id="calculating-the-path">Calculating the path</h3>
<p>Once we have obtained the configuration space, things get a lot easier. We just need to apply our trusty pal A* (or Dijkstra&rsquo;s, if you so choose) to find a path in the 3D configuration space from start to finish. Adding another dimension to the pathfinding algorithm is simple, though computational intensive.<br>
One detail to note here is that we should associate a small cost for traversing between the orientation planes. Ideally, the cost for a full rotation should be lower than the cost to move one unit along the same plane. This small cost prevents any unnecessary change of orientations the pathfinder might end up making.<br>
Finally, for our efforts, we shall be rewarded with an efficient path for our object.<br>
<img src="../images/path.gif" alt="Final Path"></p>
<p>The code for the pathfinder can be found on <a href="https://github.com/arnav-t/AGV_1">this repository</a>.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
